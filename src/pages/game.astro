---
import GameLayout from '../layouts/GameLayout.astro';
import { decodeGameState } from '../lib/urlCodec.js';
import { getAllMeals, getCostPoints, getBudgetPoints, getRandomUpgrades } from '../lib/gameData.js';

export const prerender = false;

const params = Astro.url.searchParams;
let state = decodeGameState(params);

if (!state || state.status !== 'drafting') {
  return Astro.redirect('/');
}

const currentPlayer = params.get('player') || 'A';

// Initialize player if they don't exist
if (!state.players[currentPlayer]) {
  const upgrades = await getRandomUpgrades(2);
  state = {
    ...state,
    players: {
      ...state.players,
      [currentPlayer]: {
        name: null,
        dietPreference: 3,
        upgrades: upgrades,
        picks: [],
        locked: false
      }
    }
  };
}

const player = state.players[currentPlayer];
const otherPlayerId = currentPlayer === 'A' ? 'B' : 'A';
const otherPlayer = state.players[otherPlayerId];

// Fetch full meal data for pool
const allMeals = await getAllMeals();

// Get the other player's previous picks (partial harmonies) - only from Round 2 onwards
const otherPlayerAllPicks = state.currentRound > 1
  ? (currentPlayer === 'A' ? (state.playerBAllPicks || []) : (state.playerAAllPicks || []))
  : [];
const partialHarmonyIds = otherPlayerAllPicks.filter(id => !state.harmoniesSoFar.includes(id));
const partialHarmonyMeals = partialHarmonyIds.map(id => allMeals.find(m => m.id === id)).filter(m => m);

// Combine pool with other player's picks, excluding harmonies
const poolMealIds = state.pool.map(m => m.id);
const combinedPoolIds = [...new Set([...poolMealIds, ...partialHarmonyIds])];
// Filter out meals that are already harmonies (locked in)
const availablePoolIds = combinedPoolIds.filter(id => !state.harmoniesSoFar.includes(id));
let poolMeals = availablePoolIds.map(id => allMeals.find(m => m.id === id)).filter(m => m);

// Filter by current player's diet preference (exclude meat if strict vegetarian)
// BUT keep partial harmonies regardless of diet preference
const otherPlayerPicksSet = new Set(partialHarmonyIds);
if (player.dietPreference === 1) {
  // Strict vegetarian - exclude meat dishes (dietScore >= 3) unless they're partial harmonies
  poolMeals = poolMeals.filter(meal =>
    meal.dietScore <= 2 || otherPlayerPicksSet.has(meal.id)
  );
}

// Get harmonies for display
const harmonyMeals = state.harmoniesSoFar.map(id => allMeals.find(m => m.id === id));

// Budget is total across all rounds
const budgetLimit = getBudgetPoints(state.settings.budgetCap, state.settings.mealCount);

// Calculate cost already spent on harmonies
const harmoniesCost = harmonyMeals.reduce((sum, meal) => sum + (meal ? getCostPoints(meal.cost) : 0), 0);
const harmoniesUsdTotal = harmonyMeals.reduce((sum, meal) => sum + (meal?.estimatedPrice || 0), 0);
const budgetRemaining = budgetLimit ? budgetLimit - harmoniesCost : null;
const budgetText = budgetLimit ? `${budgetLimit}` : 'No limit';

// Get sender name for OG tags (the current player who is sharing)
const senderName = player?.name || `Player ${currentPlayer}`;
---

<GameLayout senderName={senderName} currentRound={state.currentRound}>
  <div class="panel">
    <div class="panel-title">{player?.name || `Player ${currentPlayer}`} - ROUND {state.currentRound}</div>

    {harmonyMeals.length > 0 && (
      <div class="harmonies-section">
        <h3>Harmonies (Locked In)</h3>
        <div class="harmony-grid">
          {harmonyMeals.map(meal => (
            <div class="harmony-card locked">
              <span class="meal-emoji">{meal.emoji}</span>
              <div class="meal-name">{meal.name}</div>
            </div>
          ))}
        </div>
      </div>
    )}

    <div class="draft-info">
      <div class="info-row">
        <div class="info-item">
          <span class="info-label">Meals to Pick:</span>
          <span class="info-value" id="pick-count">{state.harmoniesSoFar.length} / {state.settings.mealCount}</span>
        </div>
        <div class="info-item">
          <span class="info-label">Budget:</span>
          <span class="info-value" id="budget-display">{harmoniesCost} / {budgetText} <span class="usd-total" id="usd-display">(${harmoniesUsdTotal})</span></span>
        </div>
      </div>
    </div>

    {player?.upgrades && player.upgrades.length > 0 && (
      <div class="upgrades-section">
        <h3>Your Themes</h3>
        <div class="upgrades-grid">
          {player.upgrades.map(upgrade => (
            <div class="upgrade-card" data-upgrade-id={upgrade.id}>
              <div class="upgrade-emoji">{upgrade.emoji}</div>
              <div class="upgrade-name">{upgrade.name}</div>
              <div class="upgrade-effect">{upgrade.effect}</div>
              <button class="btn-use-upgrade" data-upgrade-id={upgrade.id}>Use</button>
            </div>
          ))}
        </div>
      </div>
    )}

    <div class="meal-pool">
      {poolMeals.map(meal => (
        <div class="meal-card" data-meal-id={meal.id} data-cost={getCostPoints(meal.cost)} data-usd={meal.estimatedPrice || 0} data-partial={otherPlayerPicksSet.has(meal.id) ? "true" : "false"}>
          <div class="meal-header">
            <span class="meal-emoji">{meal.emoji}</span>
            {otherPlayerPicksSet.has(meal.id) && <span class="partner-pick-star">âœ¨</span>}
          </div>
          <div class="meal-name">{meal.name}</div>
          <div class="meal-cost">{meal.cost}</div>
          {otherPlayerPicksSet.has(meal.id) && (
            <div class="partial-harmony-badge">Partial Harmony</div>
          )}
          <div class="meal-meta">
            <span>{meal.time}min</span>
            <span>{meal.cuisine}</span>
          </div>
        </div>
      ))}
    </div>

    <div class="draft-actions">
      <button id="lock-btn" class="btn btn-primary" disabled>
        Seal & Dispatch
      </button>
      <button id="open-link-btn" class="btn btn-secondary" disabled title="Open link">
        â†’
      </button>
      <button id="copy-link-btn" class="btn btn-secondary" disabled title="Copy link">
        ðŸ”—
      </button>
    </div>
    <div id="share-message" class="share-message" style="display: none;"></div>
  </div>

  <div class="narrative">
    <p>Pick <strong>at least {state.settings.mealCount} meals</strong>.</p>
  </div>

  <script>
    import { decodeGameState, encodeGameState } from '../lib/urlCodec.js';
    import { updatePlayerPicks, lockPlayerDraft } from '../lib/gameState.js';
    import { validateDraft, resolveDraft } from '../lib/gameLogic.js';
    import { getCostPoints, getBudgetPoints, getRandomUpgrades, getRandomMeals, getAllMeals } from '../lib/gameDataClient.js';

    const params = new URLSearchParams(window.location.search);
    let state = decodeGameState(params);
    const currentPlayer = params.get('player') || 'A';

    // Initialize player if they don't exist
    if (!state.players[currentPlayer]) {
      const upgrades = await getRandomUpgrades(2);
      state = {
        ...state,
        players: {
          ...state.players,
          [currentPlayer]: {
            name: null,
            dietPreference: 3,
            upgrades: upgrades,
            picks: [],
            locked: false
          }
        }
      };
    }

    const mealCount = state.settings.mealCount;
    const budgetLimit = getBudgetPoints(state.settings.budgetCap, mealCount);

    let selectedMeals = new Set();

    // UI elements
    const pickCountEl = document.getElementById('pick-count');
    const budgetDisplayEl = document.getElementById('budget-display');
    const usdDisplayEl = document.getElementById('usd-display');
    const lockBtn = document.getElementById('lock-btn');
    const openLinkBtn = document.getElementById('open-link-btn');
    const copyLinkBtn = document.getElementById('copy-link-btn');
    const shareMessage = document.getElementById('share-message');

    // Calculate cost of harmonies (already spent)
    // Fetch all meals since harmonies are removed from pool in later rounds
    const allMeals = await getAllMeals();
    const harmoniesCost = (state.harmoniesSoFar || []).reduce((sum, mealId) => {
      const meal = allMeals.find(m => m.id === mealId);
      return sum + (meal ? getCostPoints(meal.cost) : 0);
    }, 0);
    const harmoniesUsdTotal = (state.harmoniesSoFar || []).reduce((sum, mealId) => {
      const meal = allMeals.find(m => m.id === mealId);
      return sum + (meal?.estimatedPrice || 0);
    }, 0);

    // Update displays and run live validation
    function updateDisplays() {
      const currentPicksCost = Array.from(selectedMeals).reduce((sum, id) => {
        const card = document.querySelector(`[data-meal-id="${id}"]`);
        return sum + parseInt(card.dataset.cost);
      }, 0);

      const currentPicksUsd = Array.from(selectedMeals).reduce((sum, id) => {
        const card = document.querySelector(`[data-meal-id="${id}"]`);
        return sum + parseInt(card.dataset.usd || 0);
      }, 0);

      const cumulativeCost = harmoniesCost + currentPicksCost;
      const cumulativeUsd = harmoniesUsdTotal + currentPicksUsd;

      const totalMealsSecured = state.harmoniesSoFar.length + selectedMeals.size;
      pickCountEl.textContent = `${totalMealsSecured} / ${mealCount}`;
      budgetDisplayEl.innerHTML = `${cumulativeCost} / ${budgetLimit ? budgetLimit : 'No limit'} <span class="usd-total">($${cumulativeUsd})</span>`;

      // Color coding
      pickCountEl.style.color = totalMealsSecured >= mealCount ? 'var(--primary)' : '#d35d5d';
      budgetDisplayEl.style.color = (budgetLimit && cumulativeCost > budgetLimit) ? 'var(--danger)' : 'var(--primary)';

      // Live validation
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));
      const validation = validateDraft(state, currentPlayer);

      // Check if quest will be completed
      let questComplete = false;
      if (currentPlayer === 'A') {
        const playerBAllPicks = state.playerBAllPicks || [];
        const newHarmonies = Array.from(selectedMeals).filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];
        questComplete = allHarmonies.length >= mealCount;
      } else if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const harmonies = Array.from(selectedMeals).filter(mealId => playerAPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...harmonies];
        questComplete = allHarmonies.length >= mealCount;
      }

      // Update button text based on quest completion
      if (questComplete) {
        lockBtn.textContent = 'Return Triumphant';
      } else {
        lockBtn.textContent = 'Seal & Dispatch';
      }

      if (validation.valid) {
        lockBtn.disabled = false;
        openLinkBtn.disabled = false;
        copyLinkBtn.disabled = false;
      } else {
        lockBtn.disabled = true;
        openLinkBtn.disabled = true;
        copyLinkBtn.disabled = true;
      }
    }

    // Meal card selection
    document.querySelectorAll('.meal-card').forEach(card => {
      card.addEventListener('click', (e) => {
        const mealId = parseInt(card.dataset.mealId);

        if (selectedMeals.has(mealId)) {
          // Deselect
          selectedMeals.delete(mealId);
          card.classList.remove('selected');
        } else {
          // Select
          selectedMeals.add(mealId);
          card.classList.add('selected');
        }

        updateDisplays();
      });
    });

    // Lock button
    lockBtn.addEventListener('click', async () => {
      // Final validation
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      // Lock in
      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize newest harmonies (newHarmonies) over older ones (harmoniesSoFar)
          const prioritizedHarmonies = [...newHarmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=A`;
          return;
        }

        // Otherwise, open messaging app with link for Player B
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        const shareUrl = `${window.location.origin}${targetPage}?${encoded.toString()}&player=B`;
        const message = 'Your turn to pick meals! ' + shareUrl;

        // Use Web Share API to share with partner
        if (navigator.share) {
          try {
            await navigator.share({
              title: 'Dinner Quest - Your Turn',
              text: message
            });
            shareMessage.textContent = 'Shared! Use â†’ to view next player.';
            shareMessage.style.display = 'block';
          } catch (err) {
            // User cancelled or share failed
            if (err.name !== 'AbortError') {
              console.error('Share failed:', err);
              shareMessage.textContent = 'Share failed. Copy link with ðŸ”— button.';
              shareMessage.style.display = 'block';
            }
          }
        } else {
          // Browser doesn't support Web Share API
          shareMessage.textContent = 'Copy link with ðŸ”— button to share.';
          shareMessage.style.display = 'block';
        }

        // Enable share buttons
        openLinkBtn.disabled = false;
        copyLinkBtn.disabled = false;
        return;
      }

      // Player B locks -> process round and advance
      if (currentPlayer === 'B') {
        // Find harmonies (meals both players picked)
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        // Only remove harmonies from pool, keep partial picks available
        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        // Check if we have enough meals
        if (allHarmonies.length >= state.settings.mealCount) {
          // Game complete! Prioritize full harmonies (current round) over partial (previous rounds)
          // harmonies = current round full harmonies
          // state.harmoniesSoFar = previous partial harmonies
          const prioritizedHarmonies = [...harmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=B`;
          return;
        } else {
          // Prepare for next round
          // Remove harmonies (locked in)
          // Remove meals that weren't picked by either player (not harmonies or partial harmonies)
          // Keep partial harmonies available

          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            // Remove if it's a harmony (locked in)
            if (allHarmonies.includes(meal.id)) return false;
            // Keep if it was picked by at least one player this round
            if (allPicksThisRound.has(meal.id)) return true;
            // Keep if it's a partial harmony from previous rounds
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            // Remove unpicked regular pool items
            return false;
          });

          // Refill pool to (remaining meals needed) * 5
          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);

            // Filter out meals already in pool or harmonies
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));

            newPool = [...newPool, ...filteredNewMeals];
          }

          // Unlock players and clear their picks for next round
          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };

          // Open messaging app with link for Player A (next round)
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/game?${encoded.toString()}&player=A`;
          const message = 'Next round - your turn to pick! ' + shareUrl;

          // Use Web Share API to share with partner
          if (navigator.share) {
            try {
              await navigator.share({
                title: 'Dinner Quest - Next Round',
                text: message
              });
              shareMessage.textContent = 'Shared! Use â†’ to view next round.';
              shareMessage.style.display = 'block';
            } catch (err) {
              // User cancelled or share failed
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
                shareMessage.textContent = 'Share failed. Copy link with ðŸ”— button.';
                shareMessage.style.display = 'block';
              }
            }
          } else {
            // Browser doesn't support Web Share API
            shareMessage.textContent = 'Copy link with ðŸ”— button to share.';
            shareMessage.style.display = 'block';
          }

          // Enable share buttons
          openLinkBtn.disabled = false;
          copyLinkBtn.disabled = false;
        }
      }
    });

    // Open link button
    openLinkBtn.addEventListener('click', async () => {
      // Update state with current selections
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize newest harmonies (newHarmonies) over older ones (harmoniesSoFar)
          const prioritizedHarmonies = [...newHarmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=A`;
          return;
        }

        // Otherwise, go to Player B (same round)
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        window.location.href = `${targetPage}?${encoded.toString()}&player=B`;
        return;
      }

      // Player B locks -> process round and advance
      if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize full harmonies (current round) over partial (previous rounds)
          const prioritizedHarmonies = [...harmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=B`;
        } else {
          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            if (allHarmonies.includes(meal.id)) return false;
            if (allPicksThisRound.has(meal.id)) return true;
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            return false;
          });

          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));
            newPool = [...newPool, ...filteredNewMeals];
          }

          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/game?${encoded.toString()}&player=A`;
        }
      }
    });

    // Copy link button
    copyLinkBtn.addEventListener('click', async () => {
      // Update state with current selections
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: allHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/complete?${encoded.toString()}&player=A`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Game complete! Link copied to clipboard!');
          return;
        }

        // Otherwise, copy link to Player B (same round)
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        const shareUrl = `${window.location.origin}${targetPage}?${encoded.toString()}&player=B`;
        await navigator.clipboard.writeText(shareUrl);
        alert('Link copied to clipboard!');
        return;
      }

      // Player B locks -> process round and copy link to Player A (next round)
      if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize full harmonies (current round) over partial (previous rounds)
          const prioritizedHarmonies = [...harmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/complete?${encoded.toString()}&player=B`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Game complete! Link copied to clipboard!');
        } else {
          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            if (allHarmonies.includes(meal.id)) return false;
            if (allPicksThisRound.has(meal.id)) return true;
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            return false;
          });

          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));
            newPool = [...newPool, ...filteredNewMeals];
          }

          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/game?${encoded.toString()}&player=A`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Link copied to clipboard!');
        }
      }
    });

    // Upgrade usage
    document.querySelectorAll('.btn-use-upgrade').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const upgradeId = btn.dataset.upgradeId;
        const player = state.players[currentPlayer];
        const upgrade = player.upgrades.find(u => u.id === upgradeId);

        if (!upgrade) return;

        // Apply theme to body
        document.body.className = upgrade.themeStyle || 'theme-fantasy';

        // Remove used upgrade and draw a new one
        const remainingUpgrades = player.upgrades.filter(u => u.id !== upgradeId);
        const newUpgrade = await getRandomUpgrades(1);

        // Update state with new upgrades
        state = {
          ...state,
          players: {
            ...state.players,
            [currentPlayer]: {
              ...player,
              upgrades: [...remainingUpgrades, ...newUpgrade]
            }
          }
        };

        // Update UI - remove old card and add new one
        const upgradeCard = document.querySelector(`.upgrade-card[data-upgrade-id="${upgradeId}"]`);
        if (upgradeCard && newUpgrade[0]) {
          upgradeCard.dataset.upgradeId = newUpgrade[0].id;
          upgradeCard.querySelector('.upgrade-emoji').textContent = newUpgrade[0].emoji;
          upgradeCard.querySelector('.upgrade-name').textContent = newUpgrade[0].name;
          upgradeCard.querySelector('.upgrade-effect').textContent = newUpgrade[0].effect;
          upgradeCard.querySelector('.btn-use-upgrade').dataset.upgradeId = newUpgrade[0].id;
        }

        // Show notification
        alert(`${upgrade.name} activated! Theme changed.`);
      });
    });
  </script>

  <style>
    .draft-info {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 2px solid var(--border);
    }

    .info-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .info-label {
      font-size: 14px;
      color: var(--text-dim);
    }

    .info-value {
      font-size: 22px;
      font-weight: bold;
      color: var(--text);
    }

    .usd-total {
      font-size: 14px;
      color: var(--text-dim);
      margin-left: 8px;
      font-weight: normal;
    }


    .meal-pool {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
      margin: 20px 0;
    }

    @media (max-width: 768px) {
      .meal-pool {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .meal-card {
      padding: 12px;
      background: var(--bg-panel);
      border: 2px solid var(--border);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .meal-card:hover {
      border-color: var(--accent);
      opacity: 0.9;
      transform: translateY(-2px);
    }

    .meal-card.selected {
      border-color: var(--accent);
      border-width: 3px;
      background: var(--bg-dark);
      transform: translateY(-8px) scale(1.05);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    .meal-header {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .meal-emoji {
      font-size: 40px;
    }

    .meal-cost {
      font-size: 14px;
      font-weight: bold;
      color: var(--primary);
      text-align: center;
    }

    .partner-pick-star {
      font-size: 18px;
      animation: sparkle 2s ease-in-out infinite;
    }

    @keyframes sparkle {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
    }

    .meal-card[data-partial="true"] {
      background: linear-gradient(135deg, var(--bg-panel) 0%, rgba(160, 96, 240, 0.15) 100%);
    }

    .meal-card[data-partial="true"].selected {
      border-color: var(--accent);
      border-width: 3px;
      background: linear-gradient(135deg, var(--bg-dark) 0%, rgba(160, 96, 240, 0.1) 100%);
      transform: translateY(-8px) scale(1.05);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    .meal-name {
      font-size: 15px;
      font-weight: bold;
    }

    .partial-harmony-badge {
      font-size: 12px;
      padding: 4px 8px;
      background: var(--purple);
      color: var(--bg);
      border-radius: 3px;
      text-align: center;
      font-weight: bold;
      margin: 4px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .meal-meta {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-dim);
    }

    .harmonies-section {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 3px solid var(--primary);
    }

    .harmonies-section h3 {
      font-size: 12px;
      color: var(--primary);
      margin-bottom: 12px;
    }

    .harmony-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
    }

    .harmony-card {
      padding: 16px;
      background: var(--bg);
      border: 3px solid var(--primary);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .partial-harmonies-banner {
      margin: 16px 0;
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--bg-dark) 0%, rgba(160, 96, 240, 0.15) 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .banner-label {
      font-size: 12px;
      color: var(--purple);
      font-weight: bold;
      white-space: nowrap;
    }

    .partner-picks-icons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .partner-pick-emoji {
      font-size: 28px;
      display: inline-block;
      position: relative;
      cursor: help;
      transition: transform 0.2s;
    }

    .partner-pick-emoji:hover {
      transform: scale(1.2);
    }

    .partner-pick-emoji::after {
      content: 'âœ¨';
      position: absolute;
      top: -4px;
      right: -4px;
      font-size: 14px;
      animation: sparkle 2s ease-in-out infinite;
    }

    .partial-harmonies-section {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
    }

    .partial-harmonies-section h3 {
      font-size: 13px;
      color: var(--text-dim);
      margin-bottom: 12px;
    }

    .partial-harmony-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }

    .partial-harmony-card {
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 6px;
      opacity: 0.7;
    }

    .meal-emoji-small {
      font-size: 24px;
    }

    .meal-name-small {
      font-size: 12px;
      color: var(--text-dim);
    }

    .upgrades-section {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 2px solid var(--accent);
    }

    .upgrades-section h3 {
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 12px;
      text-transform: uppercase;
    }

    .upgrades-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .upgrade-card {
      padding: 16px;
      background: var(--bg-panel);
      border: 2px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: all 0.2s;
    }

    .upgrade-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .upgrade-emoji {
      font-size: 32px;
      text-align: center;
    }

    .upgrade-name {
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      color: var(--accent);
    }

    .upgrade-effect {
      font-size: 11px;
      color: var(--text-dim);
      text-align: center;
      line-height: 1.4;
    }

    .btn-use-upgrade {
      margin-top: 8px;
      padding: 8px;
      background: var(--accent);
      color: var(--bg-dark);
      border: none;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-use-upgrade:hover {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px var(--accent-glow);
    }

    .draft-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    .share-message {
      margin-top: 12px;
      padding: 12px;
      background: var(--bg-dark);
      border: 2px solid var(--primary);
      color: var(--primary);
      font-size: 13px;
      text-align: center;
    }

    .btn {
      flex: 1;
      padding: 16px;
      font-family: 'Press Start 2P', monospace;
      font-size: 13px;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--accent);
      color: var(--bg-dark);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent);
      opacity: 0.9;
      transform: translateY(-4px);
      box-shadow: 0 6px 12px var(--accent-glow);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: var(--bg-panel);
      border: 2px solid var(--border);
      color: var(--text);
    }

    .btn-secondary:hover:not(:disabled) {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .btn-secondary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #open-link-btn,
    #copy-link-btn {
      flex: 0;
      width: 52px;
      padding: 16px 12px;
      font-size: 18px;
      background: var(--accent);
      color: var(--bg-dark);
      border: none;
    }

    #open-link-btn:hover:not(:disabled),
    #copy-link-btn:hover:not(:disabled) {
      background: var(--accent);
      opacity: 0.9;
      transform: translateY(-4px);
      box-shadow: 0 6px 12px var(--accent-glow);
      border-color: var(--accent);
    }
  </style>
</GameLayout>
