---
import GameLayout from '../layouts/GameLayout.astro';
---

<GameLayout>
  <div class="panel">
    <div class="panel-title" id="panel-title">Loading...</div>

    <!-- Harmonies section - populated by client -->
    <div class="harmonies-section" id="harmonies-section" style="display: none;">
      <h3>Harmonies (Locked In)</h3>
      <div class="harmony-grid" id="harmony-grid"></div>
    </div>

    <div class="draft-info">
      <div class="info-row">
        <div class="info-item">
          <span class="info-label">Meals to Pick:</span>
          <span class="info-value" id="pick-count">0 / 5</span>
        </div>
        <div class="info-item">
          <span class="info-label">Budget:</span>
          <span class="info-value" id="budget-display">0 / 0 <span class="usd-total" id="usd-display">($0)</span></span>
        </div>
      </div>
    </div>

    <!-- Upgrades section - populated by client -->
    <div class="upgrades-section" id="upgrades-section" style="display: none;">
      <h3>Your Themes</h3>
      <div class="upgrades-grid" id="upgrades-grid"></div>
    </div>

    <!-- Meal pool - populated by client -->
    <div class="meal-pool" id="meal-pool">
      <div class="loading-placeholder">Loading meals...</div>
    </div>

    <div class="draft-actions">
      <button id="lock-btn" class="btn btn-primary" disabled>
        Seal & Dispatch
      </button>
      <button id="open-link-btn" class="btn btn-secondary" disabled title="Open link">
        â†’
      </button>
      <button id="copy-link-btn" class="btn btn-secondary" disabled title="Copy link">
        ðŸ”—
      </button>
    </div>
    <div id="share-message" class="share-message" style="display: none;"></div>
  </div>

  <div class="narrative">
    <p>Pick <strong id="meal-count-text">at least 5 meals</strong>.</p>
  </div>

  <script>
    import { decodeGameState, encodeGameState } from '../lib/urlCodec.js';
    import { updatePlayerPicks, lockPlayerDraft } from '../lib/gameState.js';
    import { validateDraft, resolveDraft } from '../lib/gameLogic.js';
    import { getCostPoints, getBudgetPoints, getRandomUpgrades, getRandomMeals, getAllMeals, getAllUpgrades } from '../lib/gameDataClient.js';

    const params = new URLSearchParams(window.location.search);
    let state = decodeGameState(params);
    const currentPlayer = params.get('player') || 'A';

    // Apply theme from state
    if (state.theme) {
      document.body.className = state.theme;
    }

    // Track takeout meals (id -> meal object) for cost calculations
    const takeoutMeals = new Map();

    // Hydrate upgrades with full data (they're stored as just IDs in URL)
    const allUpgrades = await getAllUpgrades();
    if (state.players.A?.upgrades) {
      state.players.A.upgrades = state.players.A.upgrades.map(u =>
        allUpgrades.find(full => full.id === u.id) || u
      );
    }
    if (state.players.B?.upgrades) {
      state.players.B.upgrades = state.players.B.upgrades.map(u =>
        allUpgrades.find(full => full.id === u.id) || u
      );
    }

    // Initialize player if they don't exist
    if (!state.players[currentPlayer]) {
      const upgrades = await getRandomUpgrades(2);
      state = {
        ...state,
        players: {
          ...state.players,
          [currentPlayer]: {
            name: null,
            dietPreference: 3,
            upgrades: upgrades,
            picks: [],
            locked: false
          }
        }
      };
    }

    const mealCount = state.settings.mealCount;
    const budgetLimit = getBudgetPoints(state.settings.budgetCap, mealCount);

    let selectedMeals = new Set();

    // UI elements
    const pickCountEl = document.getElementById('pick-count');
    const budgetDisplayEl = document.getElementById('budget-display');
    const usdDisplayEl = document.getElementById('usd-display');
    const lockBtn = document.getElementById('lock-btn');
    const openLinkBtn = document.getElementById('open-link-btn');
    const copyLinkBtn = document.getElementById('copy-link-btn');
    const shareMessage = document.getElementById('share-message');

    // Calculate cost of harmonies (already spent)
    // Fetch all meals since harmonies are removed from pool in later rounds
    const allMeals = await getAllMeals();
    const harmoniesCost = (state.harmoniesSoFar || []).reduce((sum, mealId) => {
      const meal = allMeals.find(m => m.id === mealId) || takeoutMeals.get(mealId);
      return sum + (meal ? getCostPoints(meal.cost) : 0);
    }, 0);
    const harmoniesUsdTotal = (state.harmoniesSoFar || []).reduce((sum, mealId) => {
      const meal = allMeals.find(m => m.id === mealId) || takeoutMeals.get(mealId);
      return sum + (meal?.estimatedPrice || 0);
    }, 0);

    // Redirect to home if no valid state or wrong status
    if (!state || state.status !== 'drafting') {
      window.location.href = '/';
    }

    const player = state.players[currentPlayer];

    // --- Initialize page content ---

    // Set title
    document.getElementById('panel-title').textContent =
      `${player?.name || `Player ${currentPlayer}`} - ROUND ${state.currentRound}`;

    // Set narrative
    document.getElementById('meal-count-text').textContent = `at least ${mealCount} meals`;

    // Render harmonies
    const harmonyMeals = (state.harmoniesSoFar || [])
      .map(id => allMeals.find(m => m.id === id))
      .filter(meal => meal !== undefined);

    if (harmonyMeals.length > 0) {
      const harmoniesSection = document.getElementById('harmonies-section');
      const harmonyGrid = document.getElementById('harmony-grid');
      harmoniesSection.style.display = 'block';
      harmonyGrid.innerHTML = harmonyMeals.map(meal => `
        <div class="harmony-card locked">
          <span class="meal-emoji">${meal.emoji}</span>
          <div class="meal-name">${meal.name}</div>
        </div>
      `).join('');
    }

    // Render upgrades
    if (player?.upgrades && player.upgrades.length > 0) {
      const upgradesSection = document.getElementById('upgrades-section');
      const upgradesGrid = document.getElementById('upgrades-grid');
      upgradesSection.style.display = 'block';
      upgradesGrid.innerHTML = player.upgrades.map(upgrade => `
        <div class="upgrade-card" data-upgrade-id="${upgrade.id}">
          <div class="upgrade-emoji">${upgrade.emoji}</div>
          <div class="upgrade-name">${upgrade.name}</div>
          <div class="upgrade-effect">${upgrade.effect}</div>
          <button class="btn-use-upgrade" data-upgrade-id="${upgrade.id}">Use</button>
        </div>
      `).join('');
    }

    // Calculate meal pool
    const otherPlayerAllPicks = state.currentRound > 1
      ? (currentPlayer === 'A' ? (state.playerBAllPicks || []) : (state.playerAAllPicks || []))
      : [];
    const partialHarmonyIds = otherPlayerAllPicks.filter(id => !(state.harmoniesSoFar || []).includes(id));
    const otherPlayerPicksSet = new Set(partialHarmonyIds);

    const poolMealIds = state.pool.map(m => m.id);
    const combinedPoolIds = [...new Set([...poolMealIds, ...partialHarmonyIds])];
    const availablePoolIds = combinedPoolIds.filter(id => !(state.harmoniesSoFar || []).includes(id));
    let poolMeals = availablePoolIds.map(id => allMeals.find(m => m.id === id)).filter(m => m);

    // Filter by diet preference (keep partial harmonies regardless)
    if (player?.dietPreference === 1) {
      poolMeals = poolMeals.filter(meal =>
        meal.dietScore <= 2 || otherPlayerPicksSet.has(meal.id)
      );
    }

    // Render meal pool
    const mealPoolEl = document.getElementById('meal-pool');
    mealPoolEl.innerHTML = poolMeals.map(meal => `
      <div class="meal-card" data-meal-id="${meal.id}" data-cost="${getCostPoints(meal.cost)}" data-usd="${meal.estimatedPrice || 0}" data-partial="${otherPlayerPicksSet.has(meal.id) ? "true" : "false"}">
        <div class="meal-header">
          <span class="meal-emoji">${meal.emoji}</span>
          ${otherPlayerPicksSet.has(meal.id) ? '<span class="partner-pick-star">âœ¨</span>' : ''}
        </div>
        <div class="meal-name">${meal.name}</div>
        <div class="meal-cost">${meal.cost}</div>
        ${otherPlayerPicksSet.has(meal.id) ? '<div class="partial-harmony-badge">Partial Harmony</div>' : ''}
        <div class="meal-meta">
          <span>${meal.time}min</span>
          <span>${meal.cuisine}</span>
        </div>
      </div>
    `).join('');

    // Update displays and run live validation
    function updateDisplays() {
      const currentPicksCost = Array.from(selectedMeals).reduce((sum, id) => {
        const card = document.querySelector(`[data-meal-id="${id}"]`);
        return sum + parseInt(card.dataset.cost);
      }, 0);

      const currentPicksUsd = Array.from(selectedMeals).reduce((sum, id) => {
        const card = document.querySelector(`[data-meal-id="${id}"]`);
        return sum + parseInt(card.dataset.usd || 0);
      }, 0);

      const cumulativeCost = harmoniesCost + currentPicksCost;
      const cumulativeUsd = harmoniesUsdTotal + currentPicksUsd;

      const totalMealsSecured = state.harmoniesSoFar.length + selectedMeals.size;
      pickCountEl.textContent = `${totalMealsSecured} / ${mealCount}`;
      budgetDisplayEl.innerHTML = `${cumulativeCost} / ${budgetLimit ? budgetLimit : 'No limit'} <span class="usd-total">($${cumulativeUsd})</span>`;

      // Color coding
      pickCountEl.style.color = totalMealsSecured >= mealCount ? 'var(--primary)' : '#d35d5d';
      budgetDisplayEl.style.color = (budgetLimit && cumulativeCost > budgetLimit) ? 'var(--danger)' : 'var(--primary)';

      // Live validation
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));
      const validation = validateDraft(state, currentPlayer, allMeals);

      // Check if quest will be completed
      let questComplete = false;
      if (currentPlayer === 'A') {
        const playerBAllPicks = state.playerBAllPicks || [];
        const newHarmonies = Array.from(selectedMeals).filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];
        questComplete = allHarmonies.length >= mealCount;
      } else if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const harmonies = Array.from(selectedMeals).filter(mealId => playerAPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...harmonies];
        questComplete = allHarmonies.length >= mealCount;
      }

      // Update button text based on quest completion
      if (questComplete) {
        lockBtn.textContent = 'Return Triumphant';
      } else {
        lockBtn.textContent = 'Seal & Dispatch';
      }

      if (validation.valid) {
        lockBtn.disabled = false;
        openLinkBtn.disabled = false;
        copyLinkBtn.disabled = false;
      } else {
        lockBtn.disabled = true;
        openLinkBtn.disabled = true;
        copyLinkBtn.disabled = true;
      }
    }

    // Meal card selection
    document.querySelectorAll('.meal-card').forEach(card => {
      card.addEventListener('click', async (e) => {
        const mealId = parseInt(card.dataset.mealId);

        // Handle lock selection mode
        if (isSelectingToLock && activeLockUpgrade) {
          // Lock this meal
          lockedMealId = mealId;
          isSelectingToLock = false;

          // Find the meal data
          const lockedMeal = (await getAllMeals()).find(m => m.id === mealId);
          if (!lockedMeal) return;

          // Add to harmonies immediately
          if (!state.harmoniesSoFar.includes(mealId)) {
            state.harmoniesSoFar = [...state.harmoniesSoFar, mealId];
          }

          // Create or update harmonies section
          let harmoniesSection = document.querySelector('.harmonies-section');
          if (!harmoniesSection) {
            harmoniesSection = document.createElement('div');
            harmoniesSection.className = 'harmonies-section';
            harmoniesSection.innerHTML = '<h3>Harmonies (Locked In)</h3><div class="harmony-grid"></div>';
            const draftInfo = document.querySelector('.draft-info');
            draftInfo.parentNode.insertBefore(harmoniesSection, draftInfo);
          }

          // Add harmony card
          const harmonyGrid = harmoniesSection.querySelector('.harmony-grid');
          const harmonyCard = document.createElement('div');
          harmonyCard.className = 'harmony-card locked lock-harmony-card';
          harmonyCard.dataset.mealId = mealId;
          harmonyCard.innerHTML = `
            <span class="meal-emoji">${activeLockUpgrade.emoji}${lockedMeal.emoji}</span>
            <div class="meal-name">${lockedMeal.name}</div>
          `;
          harmonyGrid.appendChild(harmonyCard);

          // Remove lockable class from all cards and remove the meal from pool
          document.querySelectorAll('.meal-card').forEach(c => {
            c.classList.remove('lockable');
            if (c.dataset.mealId === mealId.toString()) {
              c.remove(); // Remove from pool entirely
            }
          });

          // Create undo button
          const upgradeCard = document.querySelector(`.upgrade-card[data-upgrade-id="${activeLockUpgrade.id}"]`);
          if (upgradeCard) {
            const undoBtn = document.createElement('button');
            undoBtn.className = 'btn-undo-lock';
            undoBtn.textContent = activeLockUpgrade.undoText || 'Undo';
            undoBtn.addEventListener('click', () => {
              // Remove from harmonies
              state.harmoniesSoFar = state.harmoniesSoFar.filter(id => id !== mealId);

              // Remove harmony card
              const harmonyCardToRemove = document.querySelector(`.lock-harmony-card[data-meal-id="${mealId}"]`);
              if (harmonyCardToRemove) {
                harmonyCardToRemove.remove();
              }

              // Hide harmonies section if empty
              const harmonyGrid = document.querySelector('.harmony-grid');
              if (harmonyGrid && harmonyGrid.children.length === 0) {
                const harmoniesSection = document.querySelector('.harmonies-section');
                if (harmoniesSection) harmoniesSection.remove();
              }

              // Re-add meal to pool
              const mealPool = document.querySelector('.meal-pool');
              const mealCard = document.createElement('div');
              mealCard.className = 'meal-card';
              mealCard.dataset.mealId = mealId;
              mealCard.dataset.cost = getCostPoints(lockedMeal.cost);
              mealCard.dataset.usd = lockedMeal.estimatedPrice || 0;
              mealCard.innerHTML = `
                <div class="meal-header">
                  <span class="meal-emoji">${lockedMeal.emoji}</span>
                </div>
                <div class="meal-name">${lockedMeal.name}</div>
                <div class="meal-cost">${lockedMeal.cost}</div>
                <div class="meal-meta">
                  <span>${lockedMeal.time}min</span>
                  <span>${lockedMeal.cuisine}</span>
                </div>
              `;

              // Re-attach click handler
              mealCard.addEventListener('click', (e) => {
                const clickedMealId = parseInt(mealCard.dataset.mealId);
                if (mealCard.classList.contains('locked')) return;

                if (selectedMeals.has(clickedMealId)) {
                  selectedMeals.delete(clickedMealId);
                  mealCard.classList.remove('selected');
                } else {
                  selectedMeals.add(clickedMealId);
                  mealCard.classList.add('selected');
                }
                updateDisplays();
              });

              mealPool.appendChild(mealCard);

              lockedMealId = null;
              undoBtn.remove();

              // Re-enable the lock upgrade button
              const lockBtn = upgradeCard.querySelector('.btn-use-upgrade');
              if (lockBtn) {
                lockBtn.disabled = false;
                lockBtn.textContent = 'Use';
              }

              // Update displays after unlock
              updateDisplays();
            });
            upgradeCard.appendChild(undoBtn);
          }

          // Update displays after locking
          updateDisplays();
          return;
        }

        // Normal selection
        // Prevent deselecting locked meals
        if (card.classList.contains('locked')) {
          return;
        }

        if (selectedMeals.has(mealId)) {
          // Deselect
          selectedMeals.delete(mealId);
          card.classList.remove('selected');
        } else {
          // Select
          selectedMeals.add(mealId);
          card.classList.add('selected');
        }

        updateDisplays();
      });
    });

    // Helper to persist used lock/takeout upgrades to player state
    function persistUsedUpgrades() {
      const player = state.players[currentPlayer];
      let updates = {};

      if (lockedMealId && activeLockUpgrade) {
        updates.usedLockId = activeLockUpgrade.id;
      }
      if (activeTakeoutUpgrade) {
        updates.usedTakeoutId = activeTakeoutUpgrade.id;
      }

      if (Object.keys(updates).length > 0) {
        state = {
          ...state,
          players: {
            ...state.players,
            [currentPlayer]: {
              ...player,
              ...updates
            }
          }
        };
      }
    }

    // Lock button
    lockBtn.addEventListener('click', async () => {
      // Final validation
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer, allMeals);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      // Persist used lock/takeout upgrades before sealing
      persistUsedUpgrades();

      // Lock in
      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize newest harmonies (newHarmonies) over older ones (harmoniesSoFar)
          const prioritizedHarmonies = [...newHarmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=A`;
          return;
        }

        // Otherwise, open messaging app with link for Player B
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        const shareUrl = `${window.location.origin}${targetPage}?${encoded.toString()}&player=B`;
        const message = 'Your turn to pick meals! ' + shareUrl;

        // Use Web Share API to share with partner
        if (navigator.share) {
          try {
            await navigator.share({
              title: 'Dinner Quest - Your Turn',
              text: message
            });
            shareMessage.textContent = 'Shared! Use â†’ to view next player.';
            shareMessage.style.display = 'block';
          } catch (err) {
            // User cancelled or share failed
            if (err.name !== 'AbortError') {
              console.error('Share failed:', err);
              shareMessage.textContent = 'Share failed. Copy link with ðŸ”— button.';
              shareMessage.style.display = 'block';
            }
          }
        } else {
          // Browser doesn't support Web Share API
          shareMessage.textContent = 'Copy link with ðŸ”— button to share.';
          shareMessage.style.display = 'block';
        }

        // Enable share buttons
        openLinkBtn.disabled = false;
        copyLinkBtn.disabled = false;
        return;
      }

      // Player B locks -> process round and advance
      if (currentPlayer === 'B') {
        // Find harmonies (meals both players picked)
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        // Only remove harmonies from pool, keep partial picks available
        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        // Check if we have enough meals
        if (allHarmonies.length >= state.settings.mealCount) {
          // Game complete! Prioritize full harmonies (current round) over partial (previous rounds)
          // newHarmoniesFromB = current round full harmonies
          // state.harmoniesSoFar = previous partial harmonies
          const prioritizedHarmonies = [...newHarmoniesFromB, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=B`;
          return;
        } else {
          // Prepare for next round
          // Remove harmonies (locked in)
          // Remove meals that weren't picked by either player (not harmonies or partial harmonies)
          // Keep partial harmonies available

          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            // Remove if it's a harmony (locked in)
            if (allHarmonies.includes(meal.id)) return false;
            // Keep if it was picked by at least one player this round
            if (allPicksThisRound.has(meal.id)) return true;
            // Keep if it's a partial harmony from previous rounds
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            // Remove unpicked regular pool items
            return false;
          });

          // Refill pool to (remaining meals needed) * 5
          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);

            // Filter out meals already in pool or harmonies
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));

            newPool = [...newPool, ...filteredNewMeals];
          }

          // Unlock players and clear their picks for next round
          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };

          // Open messaging app with link for Player A (next round)
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/game?${encoded.toString()}&player=A`;
          const message = 'Next round - your turn to pick! ' + shareUrl;

          // Use Web Share API to share with partner
          if (navigator.share) {
            try {
              await navigator.share({
                title: 'Dinner Quest - Next Round',
                text: message
              });
              shareMessage.textContent = 'Shared! Use â†’ to view next round.';
              shareMessage.style.display = 'block';
            } catch (err) {
              // User cancelled or share failed
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
                shareMessage.textContent = 'Share failed. Copy link with ðŸ”— button.';
                shareMessage.style.display = 'block';
              }
            }
          } else {
            // Browser doesn't support Web Share API
            shareMessage.textContent = 'Copy link with ðŸ”— button to share.';
            shareMessage.style.display = 'block';
          }

          // Enable share buttons
          openLinkBtn.disabled = false;
          copyLinkBtn.disabled = false;
        }
      }
    });

    // Open link button
    openLinkBtn.addEventListener('click', async () => {
      // Update state with current selections
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer, allMeals);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      // Persist used lock/takeout upgrades before sealing
      persistUsedUpgrades();

      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize newest harmonies (newHarmonies) over older ones (harmoniesSoFar)
          const prioritizedHarmonies = [...newHarmonies, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=A`;
          return;
        }

        // Otherwise, go to Player B (same round)
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        window.location.href = `${targetPage}?${encoded.toString()}&player=B`;
        return;
      }

      // Player B locks -> process round and advance
      if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize full harmonies (current round) over partial (previous rounds)
          const prioritizedHarmonies = [...newHarmoniesFromB, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/complete?${encoded.toString()}&player=B`;
        } else {
          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            if (allHarmonies.includes(meal.id)) return false;
            if (allPicksThisRound.has(meal.id)) return true;
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            return false;
          });

          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));
            newPool = [...newPool, ...filteredNewMeals];
          }

          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };
          const encoded = encodeGameState(state);
          window.location.href = `/game?${encoded.toString()}&player=A`;
        }
      }
    });

    // Copy link button
    copyLinkBtn.addEventListener('click', async () => {
      // Update state with current selections
      state = updatePlayerPicks(state, currentPlayer, Array.from(selectedMeals));

      const validation = validateDraft(state, currentPlayer, allMeals);
      if (!validation.valid) {
        alert('Draft is invalid. Please fix errors first.');
        return;
      }

      // Persist used lock/takeout upgrades before sealing
      persistUsedUpgrades();

      state = lockPlayerDraft(state, currentPlayer);

      // Player A locks -> check if we have enough harmonies
      if (currentPlayer === 'A') {
        const playerAPicks = state.players.A.picks;
        const playerBAllPicks = state.playerBAllPicks || [];

        // Find harmonies between A's current picks and B's all picks
        const newHarmonies = playerAPicks.filter(mealId => playerBAllPicks.includes(mealId));
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmonies];

        // Update playerAAllPicks and harmoniesSoFar immediately
        const updatedPlayerAAllPicks = [...(state.playerAAllPicks || []), ...playerAPicks];
        state = {
          ...state,
          harmoniesSoFar: allHarmonies,
          playerAAllPicks: updatedPlayerAAllPicks
        };

        // If we have enough harmonies, game is complete
        if (allHarmonies.length >= state.settings.mealCount) {
          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: allHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/complete?${encoded.toString()}&player=A`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Game complete! Link copied to clipboard!');
          return;
        }

        // Otherwise, copy link to Player B (same round)
        const encoded = encodeGameState(state);
        const playerBJoined = state.players.B !== null;
        const targetPage = playerBJoined ? '/game' : '/waiting';
        const shareUrl = `${window.location.origin}${targetPage}?${encoded.toString()}&player=B`;
        await navigator.clipboard.writeText(shareUrl);
        alert('Link copied to clipboard!');
        return;
      }

      // Player B locks -> process round and copy link to Player A (next round)
      if (currentPlayer === 'B') {
        const playerAPicks = state.players.A.picks;
        const playerBPicks = state.players.B.picks;
        const playerAAllPicks = state.playerAAllPicks || []; // Already updated by Player A
        const playerBAllPicks = [...(state.playerBAllPicks || []), ...playerBPicks];

        // Find NEW harmonies from Player B's picks (Player A's harmonies already counted)
        const newHarmoniesFromB = playerBPicks.filter(mealId =>
          playerAAllPicks.includes(mealId) && !state.harmoniesSoFar.includes(mealId)
        );

        // Add new harmonies to accumulated list
        const allHarmonies = [...state.harmoniesSoFar, ...newHarmoniesFromB];

        // Update playerBAllPicks
        state = {
          ...state,
          playerBAllPicks,
          harmoniesSoFar: allHarmonies
        };

        const allPickedMeals = new Set([...playerAPicks, ...playerBPicks]);
        const usedMeals = [...state.usedMeals, ...Array.from(allPickedMeals)];

        if (allHarmonies.length >= state.settings.mealCount) {
          // Prioritize full harmonies (current round) over partial (previous rounds)
          const prioritizedHarmonies = [...newHarmoniesFromB, ...state.harmoniesSoFar];

          state = {
            ...state,
            status: 'complete',
            results: {
              finalMenu: prioritizedHarmonies.slice(0, state.settings.mealCount),
              harmonies: allHarmonies,
              conflicts: []
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/complete?${encoded.toString()}&player=B`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Game complete! Link copied to clipboard!');
        } else {
          const allPicksThisRound = new Set([...playerAPicks, ...playerBPicks]);
          let newPool = state.pool.filter(meal => {
            if (allHarmonies.includes(meal.id)) return false;
            if (allPicksThisRound.has(meal.id)) return true;
            const isPartialHarmony = (playerAAllPicks.includes(meal.id) || playerBAllPicks.includes(meal.id))
                                     && !state.harmoniesSoFar.includes(meal.id);
            if (isPartialHarmony) return true;
            return false;
          });

          const mealsStillNeeded = state.settings.mealCount - allHarmonies.length;
          const targetPoolSize = mealsStillNeeded * 5;
          const mealsNeeded = targetPoolSize - newPool.length;

          if (mealsNeeded > 0) {
            const avgDiet = (state.players.A.dietPreference + state.players.B.dietPreference) / 2;
            const newMeals = await getRandomMeals(mealsNeeded, state.settings.allergies, avgDiet);
            const existingIds = new Set([...newPool.map(m => m.id), ...allHarmonies]);
            const filteredNewMeals = newMeals.filter(m => !existingIds.has(m.id));
            newPool = [...newPool, ...filteredNewMeals];
          }

          state = {
            ...state,
            currentRound: state.currentRound + 1,
            status: 'drafting',
            pool: newPool,
            harmoniesSoFar: allHarmonies,
            usedMeals: usedMeals,
            playerAAllPicks: playerAAllPicks,
            playerBAllPicks: playerBAllPicks,
            players: {
              A: { ...state.players.A, picks: [], locked: false },
              B: { ...state.players.B, picks: [], locked: false }
            }
          };
          const encoded = encodeGameState(state);
          const shareUrl = `${window.location.origin}/game?${encoded.toString()}&player=A`;
          await navigator.clipboard.writeText(shareUrl);
          alert('Link copied to clipboard!');
        }
      }
    });

    // Track lock state
    let isSelectingToLock = false;
    let activeLockUpgrade = null;
    let lockedMealId = null;
    let activeTakeoutUpgrade = null;

    // Upgrade usage
    document.querySelectorAll('.btn-use-upgrade').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const upgradeId = btn.dataset.upgradeId;
        const player = state.players[currentPlayer];
        const upgrade = player.upgrades.find(u => u.id === upgradeId);

        if (!upgrade) return;

        // Handle lock upgrades
        if (upgrade.type === 'lock') {
          isSelectingToLock = true;
          activeLockUpgrade = upgrade;

          // Update button to show selecting state
          btn.textContent = 'Click a meal...';
          btn.disabled = true;

          // Add visual indicator to meal cards
          document.querySelectorAll('.meal-card').forEach(card => {
            card.classList.add('lockable');
          });
          return;
        }

        // Handle takeout upgrades
        if (upgrade.type === 'takeout') {
          // Track the active takeout upgrade
          activeTakeoutUpgrade = upgrade;

          // Create a fake meal ID for the takeout
          const takeoutId = `takeout-${Date.now()}`;

          // Create meal object from upgrade data
          const takeoutMeal = {
            id: takeoutId,
            name: upgrade.mealName || 'Takeout',
            emoji: upgrade.emoji,
            cost: upgrade.mealCost || '$$$',
            estimatedPrice: upgrade.mealCost === '$' ? 10 : upgrade.mealCost === '$$' ? 20 : 30,
            time: 0,
            cuisine: 'Takeout'
          };

          // Store takeout meal for cost calculations
          takeoutMeals.set(takeoutId, takeoutMeal);

          // Add to harmonies immediately
          if (!state.harmoniesSoFar.includes(takeoutId)) {
            state.harmoniesSoFar = [...state.harmoniesSoFar, takeoutId];
          }

          // Create or update harmonies section
          let harmoniesSection = document.querySelector('.harmonies-section');
          if (!harmoniesSection) {
            harmoniesSection = document.createElement('div');
            harmoniesSection.className = 'harmonies-section';
            harmoniesSection.innerHTML = '<h3>Harmonies (Locked In)</h3><div class="harmony-grid"></div>';
            const draftInfo = document.querySelector('.draft-info');
            draftInfo.parentNode.insertBefore(harmoniesSection, draftInfo);
          }

          // Add harmony card
          const harmonyGrid = harmoniesSection.querySelector('.harmony-grid');
          const harmonyCard = document.createElement('div');
          harmonyCard.className = 'harmony-card locked takeout-harmony-card';
          harmonyCard.dataset.mealId = takeoutId;
          harmonyCard.innerHTML = `
            <span class="meal-emoji">${takeoutMeal.emoji}</span>
            <div class="meal-name">${takeoutMeal.name}</div>
          `;
          harmonyGrid.appendChild(harmonyCard);

          // Disable the upgrade button
          btn.disabled = true;
          btn.textContent = 'âœ“ Used';

          // Create undo button
          const upgradeCard = document.querySelector(`.upgrade-card[data-upgrade-id="${upgrade.id}"]`);
          if (upgradeCard) {
            const undoBtn = document.createElement('button');
            undoBtn.className = 'btn-undo-lock';
            undoBtn.textContent = upgrade.undoText || 'Undo';
            undoBtn.addEventListener('click', () => {
              // Remove from harmonies
              state.harmoniesSoFar = state.harmoniesSoFar.filter(id => id !== takeoutId);

              // Remove from takeout meals map
              takeoutMeals.delete(takeoutId);

              // Clear active takeout tracking
              activeTakeoutUpgrade = null;

              // Remove harmony card
              const harmonyCardToRemove = document.querySelector(`.takeout-harmony-card[data-meal-id="${takeoutId}"]`);
              if (harmonyCardToRemove) {
                harmonyCardToRemove.remove();
              }

              // Hide harmonies section if empty
              const harmonyGrid = document.querySelector('.harmony-grid');
              if (harmonyGrid && harmonyGrid.children.length === 0) {
                const harmoniesSection = document.querySelector('.harmonies-section');
                if (harmoniesSection) harmoniesSection.remove();
              }

              undoBtn.remove();

              // Re-enable the upgrade button
              btn.disabled = false;
              btn.textContent = 'Use';

              // Update displays after removing takeout
              updateDisplays();
            });
            upgradeCard.appendChild(undoBtn);
          }

          // Update displays after adding takeout
          updateDisplays();
          return;
        }

        // Handle redraw upgrades
        if (upgrade.type === 'redraw') {
          // Save original pool for undo
          const originalPool = [...state.pool];
          const originalPoolCards = document.querySelector('.meal-pool').innerHTML;

          // Get partial harmony IDs (other player's picks that aren't harmonized yet)
          const otherPlayerAllPicks = currentPlayer === 'A'
            ? (state.playerBAllPicks || [])
            : (state.playerAAllPicks || []);
          const partialHarmonyIds = otherPlayerAllPicks.filter(id => !state.harmoniesSoFar.includes(id));

          // Keep partial harmonies in the pool
          const mealsToKeep = state.pool.filter(meal => partialHarmonyIds.includes(meal.id));
          const mealsToKeepIds = new Set(mealsToKeep.map(m => m.id));

          // Calculate how many new meals we need
          const targetPoolSize = (state.settings.mealCount - (state.harmoniesSoFar?.length || 0)) * 5;
          const mealsNeeded = targetPoolSize - mealsToKeep.length;

          // Fetch new meals
          const avgDiet = (state.players.A?.dietPreference || 3 + state.players.B?.dietPreference || 3) / 2;
          const newMeals = await getRandomMeals(mealsNeeded + 10, state.settings.allergies || [], avgDiet);

          // Filter out meals we're keeping and already used meals
          const usedMealIds = new Set([
            ...mealsToKeepIds,
            ...(state.harmoniesSoFar || []),
            ...(state.usedMeals || [])
          ]);
          const filteredNewMeals = newMeals.filter(m => !usedMealIds.has(m.id)).slice(0, mealsNeeded);

          // Create new pool
          const newPool = [...mealsToKeep, ...filteredNewMeals];
          state = { ...state, pool: newPool };

          // Clear current selections (since pool is changing)
          selectedMeals.clear();

          // Update the meal pool UI
          const mealPoolEl = document.querySelector('.meal-pool');
          mealPoolEl.innerHTML = '';

          for (const meal of newPool) {
            const isPartial = partialHarmonyIds.includes(meal.id);
            const mealCard = document.createElement('div');
            mealCard.className = 'meal-card';
            mealCard.dataset.mealId = meal.id;
            mealCard.dataset.cost = getCostPoints(meal.cost);
            mealCard.dataset.usd = meal.estimatedPrice || 0;
            mealCard.dataset.partial = isPartial ? 'true' : 'false';
            mealCard.innerHTML = `
              <div class="meal-header">
                <span class="meal-emoji">${meal.emoji}</span>
                ${isPartial ? '<span class="partner-pick-star">âœ¨</span>' : ''}
              </div>
              <div class="meal-name">${meal.name}</div>
              <div class="meal-cost">${meal.cost}</div>
              ${isPartial ? '<div class="partial-harmony-badge">Partial Harmony</div>' : ''}
              <div class="meal-meta">
                <span>${meal.time}min</span>
                <span>${meal.cuisine}</span>
              </div>
            `;

            // Add click handler
            mealCard.addEventListener('click', () => {
              const mealId = parseInt(mealCard.dataset.mealId);

              // Handle lock selection mode
              if (isSelectingToLock && activeLockUpgrade) {
                // Same lock logic as before
                return;
              }

              if (mealCard.classList.contains('locked')) return;

              if (selectedMeals.has(mealId)) {
                selectedMeals.delete(mealId);
                mealCard.classList.remove('selected');
              } else {
                selectedMeals.add(mealId);
                mealCard.classList.add('selected');
              }
              updateDisplays();
            });

            mealPoolEl.appendChild(mealCard);
          }

          // Disable the upgrade button
          btn.disabled = true;
          btn.textContent = 'âœ“ Used';

          // Create undo button
          const upgradeCard = document.querySelector(`.upgrade-card[data-upgrade-id="${upgrade.id}"]`);
          if (upgradeCard) {
            const undoBtn = document.createElement('button');
            undoBtn.className = 'btn-undo-lock';
            undoBtn.textContent = upgrade.undoText || 'Undo';
            undoBtn.addEventListener('click', () => {
              // Restore original pool
              state = { ...state, pool: originalPool };

              // Clear selections
              selectedMeals.clear();

              // Restore original pool UI
              mealPoolEl.innerHTML = originalPoolCards;

              // Re-attach click handlers to restored cards
              document.querySelectorAll('.meal-card').forEach(card => {
                card.addEventListener('click', () => {
                  const mealId = parseInt(card.dataset.mealId);

                  if (isSelectingToLock && activeLockUpgrade) return;
                  if (card.classList.contains('locked')) return;

                  if (selectedMeals.has(mealId)) {
                    selectedMeals.delete(mealId);
                    card.classList.remove('selected');
                  } else {
                    selectedMeals.add(mealId);
                    card.classList.add('selected');
                  }
                  updateDisplays();
                });
              });

              undoBtn.remove();

              // Re-enable the upgrade button
              btn.disabled = false;
              btn.textContent = 'Use';

              updateDisplays();
            });
            upgradeCard.appendChild(undoBtn);
          }

          updateDisplays();
          return;
        }

        // Handle theme upgrades - one theme per round
        if (upgrade.type === 'theme') {
          if (player.usedThemeRound === state.currentRound) {
            return;
          }

          // Apply theme to body
          document.body.className = upgrade.themeStyle || 'theme-fantasy';

          // Mark theme as used for this round
          state = {
            ...state,
            players: {
              ...state.players,
              [currentPlayer]: {
                ...player,
                usedThemeRound: state.currentRound,
                usedThemeId: upgradeId
              }
            }
          };

          // Disable all theme buttons
          document.querySelectorAll('.btn-use-upgrade').forEach(b => {
            const btnUpgrade = player.upgrades.find(u => u.id === b.dataset.upgradeId);
            if (btnUpgrade?.type === 'theme') {
              b.disabled = true;
              if (b.dataset.upgradeId === upgradeId) {
                b.textContent = 'âœ—';
                const card = document.querySelector(`.upgrade-card[data-upgrade-id="${upgradeId}"]`);
                if (card) card.classList.add('used');
              } else {
                const otherUpgrade = player.upgrades.find(u => u.id === b.dataset.upgradeId);
                b.textContent = otherUpgrade?.rejectionText || 'Not this time';
              }
            }
          });
        }
      });
    });

    // Disable theme buttons if already used this round
    if (player.usedThemeRound === state.currentRound && player.usedThemeId) {
      document.querySelectorAll('.btn-use-upgrade').forEach(btn => {
        const btnUpgrade = player.upgrades.find(u => u.id === btn.dataset.upgradeId);
        if (btnUpgrade?.type === 'theme') {
          btn.disabled = true;
          if (btn.dataset.upgradeId === player.usedThemeId) {
            btn.textContent = 'âœ—';
            const card = document.querySelector(`.upgrade-card[data-upgrade-id="${player.usedThemeId}"]`);
            if (card) card.classList.add('used');
          } else {
            btn.textContent = btnUpgrade?.rejectionText || 'Not this time';
          }
        }
      });
    }

    // Disable lock/takeout buttons if already used (persists across rounds)
    if (player.usedLockId || player.usedTakeoutId) {
      document.querySelectorAll('.btn-use-upgrade').forEach(btn => {
        const upgradeId = btn.dataset.upgradeId;
        const btnUpgrade = player.upgrades.find(u => u.id === upgradeId);

        // Check if this is the used lock upgrade
        if (btnUpgrade?.type === 'lock' && player.usedLockId === upgradeId) {
          btn.disabled = true;
          btn.textContent = 'âœ“ Used';
          const card = document.querySelector(`.upgrade-card[data-upgrade-id="${upgradeId}"]`);
          if (card) card.classList.add('used');
        }

        // Check if this is the used takeout upgrade
        if (btnUpgrade?.type === 'takeout' && player.usedTakeoutId === upgradeId) {
          btn.disabled = true;
          btn.textContent = 'âœ“ Used';
          const card = document.querySelector(`.upgrade-card[data-upgrade-id="${upgradeId}"]`);
          if (card) card.classList.add('used');
        }
      });
    }
  </script>

  <style>
    .draft-info {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 2px solid var(--border);
    }

    .info-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .info-label {
      font-size: 14px;
      color: var(--text-dim);
    }

    .info-value {
      font-size: 22px;
      font-weight: bold;
      color: var(--text);
    }

    .usd-total {
      font-size: 14px;
      color: var(--text-dim);
      margin-left: 8px;
      font-weight: normal;
    }


    .meal-pool {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
      margin: 20px 0;
    }

    @media (max-width: 768px) {
      .meal-pool {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .meal-card {
      padding: 12px;
      background: var(--bg-panel);
      border: 2px solid var(--border);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .meal-card:hover {
      border-color: var(--accent);
      opacity: 0.9;
      transform: translateY(-2px);
    }

    .meal-card.selected {
      border-color: var(--accent);
      border-width: 3px;
      background: var(--bg-dark);
      transform: translateY(-8px) scale(1.05);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    .meal-header {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .meal-emoji {
      font-size: 40px;
    }

    .meal-cost {
      font-size: 14px;
      font-weight: bold;
      color: var(--primary);
      text-align: center;
    }

    .partner-pick-star {
      font-size: 18px;
      animation: sparkle 2s ease-in-out infinite;
    }

    @keyframes sparkle {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
    }

    .meal-card[data-partial="true"] {
      background: linear-gradient(135deg, var(--bg-panel) 0%, rgba(160, 96, 240, 0.15) 100%);
    }

    .meal-card[data-partial="true"].selected {
      border-color: var(--accent);
      border-width: 3px;
      background: linear-gradient(135deg, var(--bg-dark) 0%, rgba(160, 96, 240, 0.1) 100%);
      transform: translateY(-8px) scale(1.05);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    .meal-card.lockable {
      border-color: var(--accent);
      animation: pulse 1.5s ease-in-out infinite;
      cursor: pointer;
    }

    .meal-card.locked {
      position: relative;
      border-color: var(--success);
      border-width: 3px;
      box-shadow: 0 0 20px var(--success);
    }

    .lock-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 32px;
      z-index: 20;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 10px var(--accent-glow); }
      50% { box-shadow: 0 0 20px var(--accent-glow), 0 0 30px var(--accent-glow); }
    }

    .btn-undo-lock {
      margin-top: 8px;
      padding: 8px;
      background: var(--danger);
      color: var(--text);
      border: none;
      border-radius: 0;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-appearance: none;
      appearance: none;
      text-transform: none;
      letter-spacing: normal;
      width: 100%;
      box-sizing: border-box;
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .btn-undo-lock {
        margin-top: 6px;
        padding: 6px;
        font-size: 10px;
      }
    }

    .btn-undo-lock:hover {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(255, 64, 64, 0.4);
    }

    .meal-name {
      font-size: 15px;
      font-weight: bold;
    }

    .partial-harmony-badge {
      font-size: 14px;
      padding: 4px 8px;
      background: var(--purple);
      color: var(--bg);
      border-radius: 3px;
      text-align: center;
      font-weight: bold;
      margin: 4px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .meal-meta {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      color: var(--text-dim);
    }

    .harmonies-section {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 3px solid var(--primary);
    }

    .harmonies-section h3 {
      font-size: 14px;
      color: var(--primary);
      margin-bottom: 12px;
    }

    .harmony-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
    }

    .harmony-card {
      padding: 16px;
      background: var(--bg);
      border: 3px solid var(--primary);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .partial-harmonies-banner {
      margin: 16px 0;
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--bg-dark) 0%, rgba(160, 96, 240, 0.15) 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .banner-label {
      font-size: 14px;
      color: var(--purple);
      font-weight: bold;
      white-space: nowrap;
    }

    .partner-picks-icons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .partner-pick-emoji {
      font-size: 28px;
      display: inline-block;
      position: relative;
      cursor: help;
      transition: transform 0.2s;
    }

    .partner-pick-emoji:hover {
      transform: scale(1.2);
    }

    .partner-pick-emoji::after {
      content: 'âœ¨';
      position: absolute;
      top: -4px;
      right: -4px;
      font-size: 14px;
      animation: sparkle 2s ease-in-out infinite;
    }

    .partial-harmonies-section {
      margin: 20px 0;
      padding: 16px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
    }

    .partial-harmonies-section h3 {
      font-size: 14px;
      color: var(--text-dim);
      margin-bottom: 12px;
    }

    .partial-harmony-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }

    .partial-harmony-card {
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 6px;
      opacity: 0.7;
    }

    .meal-emoji-small {
      font-size: 24px;
    }

    .meal-name-small {
      font-size: 14px;
      color: var(--text-dim);
    }

    .upgrades-section {
      margin: 20px 0;
      padding: 12px;
      background: var(--bg-dark);
      border: 2px solid var(--accent);
    }

    .upgrades-section h3 {
      font-size: 14px;
      color: var(--accent);
      margin-bottom: 12px;
      text-transform: uppercase;
    }

    .upgrades-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    @media (max-width: 768px) {
      .upgrades-section {
        padding: 10px;
      }

      .upgrades-grid {
        display: flex;
        overflow-x: auto;
        gap: 10px;
        padding-bottom: 8px;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
      }

      .upgrades-grid::-webkit-scrollbar {
        height: 6px;
      }

      .upgrades-grid::-webkit-scrollbar-track {
        background: var(--bg-panel);
      }

      .upgrades-grid::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }
    }

    .upgrade-card {
      padding: 16px;
      background: var(--bg-panel);
      border: 2px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: all 0.2s;
    }

    @media (max-width: 768px) {
      .upgrade-card {
        min-width: 160px;
        max-width: 180px;
        flex-shrink: 0;
        padding: 12px;
        gap: 6px;
      }
    }

    .upgrade-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .upgrade-card.used {
      opacity: 0.4;
      position: relative;
    }

    .upgrade-card.used::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        to bottom right,
        transparent 0%,
        transparent calc(50% - 2px),
        var(--danger) calc(50% - 2px),
        var(--danger) calc(50% + 2px),
        transparent calc(50% + 2px),
        transparent 100%
      ),
      linear-gradient(
        to top right,
        transparent 0%,
        transparent calc(50% - 2px),
        var(--danger) calc(50% - 2px),
        var(--danger) calc(50% + 2px),
        transparent calc(50% + 2px),
        transparent 100%
      );
      pointer-events: none;
    }

    .upgrade-card.used:hover {
      transform: none;
      border-color: var(--border);
    }

    .upgrade-emoji {
      font-size: 32px;
      text-align: center;
    }

    @media (max-width: 768px) {
      .upgrade-emoji {
        font-size: 24px;
      }
    }

    .upgrade-name {
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      color: var(--accent);
    }

    @media (max-width: 768px) {
      .upgrade-name {
        font-size: 12px;
      }
    }

    .upgrade-effect {
      font-size: 14px;
      color: var(--text-dim);
      text-align: center;
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .upgrade-effect {
        font-size: 12px;
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
    }

    .btn-use-upgrade {
      margin-top: 8px;
      padding: 8px;
      background: var(--accent);
      color: var(--bg-dark);
      border: none;
      border-radius: 0;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-appearance: none;
      appearance: none;
      text-transform: none;
      letter-spacing: normal;
      width: 100%;
      box-sizing: border-box;
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .btn-use-upgrade {
        margin-top: 6px;
        padding: 6px;
        font-size: 10px;
      }
    }

    .btn-use-upgrade:hover:not(:disabled) {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px var(--accent-glow);
    }

    .btn-use-upgrade:disabled {
      background: var(--text-dim);
      color: var(--bg-panel);
      cursor: not-allowed;
      opacity: 0.5;
      transform: none;
      box-shadow: none;
    }

    .draft-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    .share-message {
      margin-top: 12px;
      padding: 12px;
      background: var(--bg-dark);
      border: 2px solid var(--primary);
      color: var(--primary);
      font-size: 14px;
      text-align: center;
    }

    .btn {
      flex: 1;
      padding: 16px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--accent);
      color: var(--bg-dark);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent);
      opacity: 0.9;
      transform: translateY(-4px);
      box-shadow: 0 6px 12px var(--accent-glow);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: var(--bg-panel);
      border: 2px solid var(--border);
      color: var(--text);
    }

    .btn-secondary:hover:not(:disabled) {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .btn-secondary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #open-link-btn,
    #copy-link-btn {
      flex: 0;
      width: 52px;
      padding: 16px 12px;
      font-size: 18px;
      background: var(--accent);
      color: var(--bg-dark);
      border: none;
    }

    #open-link-btn:hover:not(:disabled),
    #copy-link-btn:hover:not(:disabled) {
      background: var(--accent);
      opacity: 0.9;
      transform: translateY(-4px);
      box-shadow: 0 6px 12px var(--accent-glow);
      border-color: var(--accent);
    }
  </style>
</GameLayout>
